# Проект:  "Разработка стратегии в стиле боя в игре "Герои Меча и Магии 3" против искусственного интеллекта".
Проект включает в себя реализацию 4-х методов игры с заданной сложностью алгоритмов или выше.

Проект **Heroes Task** реализует ключевые функциональные возможности для игровой библиотеки `heroes_task_lib`. В рамках проекта разработаны алгоритмы и методы, которые реализуют требования четырех интерфейсов: `GeneratePreset`, `SimulateBattle`, `SuitableForAttackUnitsFinder` и `UnitTargetPathFinder`. Эти интерфейсы управляют основными игровыми механиками, включая генерацию армий, симуляцию сражений, определение целей для атаки и поиск оптимальных путей.

---

## **Структура проекта**

Проект содержит реализации следующих интерфейсов:

1. **`GeneratePreset`**
    - **Метод:** `Army generate(List<Unit> unitList, int maxPoints)`
    - **Цель:** Генерация пресета армии противника путём оптимизации выбора юнитов на основе их эффективности и стоимости.
    - **Сложность алгоритма:** O(n log n) (сортировка) + O(n) (выбор юнитов), итого O(n log n).

2. **`SimulateBattle`**
    - **Метод:** `void simulate(Army playerArmy, Army computerArmy)`
    - **Цель:** Симуляция боя между армией игрока и армией компьютера.
    - **Сложность алгоритма:** O(n² log n), если операции атаки выполняются за O(1).

3. **`SuitableForAttackUnitsFinder`**
    - **Метод:** `List<Unit> getSuitableUnits(List<List<Unit>> unitsByRow, boolean isLeftArmyTarget)`
    - **Цель:** Определение подходящих для атаки юнитов с учётом их позиции и видимости.
    - **Сложность алгоритма:** O(n * m), где `n` — количество рядов, а `m` — количество юнитов в ряду.

4. **`UnitTargetPathFinder`**
    - **Метод:** `List<Edge> getTargetPath(Unit attackUnit, Unit targetUnit, List<Unit> existingUnitList)`
    - **Цель:** Вычисление кратчайшего пути между атакующим и целью на сетке поля боя.
    - **Сложность алгоритма:** O((WIDTH × HEIGHT) log(WIDTH × HEIGHT)).

---

## **Описание каждой реализации**

### **1. `GeneratePresetImpl`**
Генерирует армию компьютера, выбирая юнитов с максимальным соотношением эффективности к стоимости.

#### **Процесс:**
- Юниты сортируются по эффективности, определяемой формулой `(baseAttack + health) / cost`.
- В армию добавляется не более 11 юнитов каждого типа, с учётом ограничения `maxPoints`.
- Юнитам назначаются уникальные имена и случайные координаты.

#### **Основные методы:**
- `sortUnitsByEffectiveness(List<Unit>)`: сортирует юниты по их эффективности.
- `addUnitsToArmy(Unit, int, List<Unit>)`: добавляет заданное количество юнитов в армию.
- `assignCoordinates(List<Unit>)`: присваивает случайные координаты юнитам, избегая дубликатов.

---

### **2. `SimulateBattleImpl`**
Симулирует пошаговый бой между двумя армиями, чередуя атаки до тех пор, пока одна из армий не будет побеждена.

#### **Процесс:**
- Юниты каждой армии поочерёдно атакуют цели, используя метод `unit.getProgram().attack()`.
- Мёртвые юниты удаляются из армий.
- После каждой атаки логирование происходит через `printBattleLog.printBattleLog()`.

#### **Основные методы:**
- `executeAttacks(Set<Unit>, Set<Unit>)`: выполняет атаки от одного набора юнитов к другому.

---

### **3. `SuitableForAttackUnitsFinderImpl`**
Определяет подходящих юнитов для атаки на основе видимости и позиции.

#### **Процесс:**
- Перебираются строки юнитов для поиска подходящих целей.
- Юниты считаются подходящими, если они живы и находятся в крайней левой или правой позиции ряда.

#### **Основные методы:**
- `findSuitableUnitsInRow(List<Unit>, boolean)`: фильтрует подходящие юниты из одного ряда.
- `isRightmostUnit(List<Unit>, int)`: проверяет, является ли юнит самым правым в ряду.
- `isLeftmostUnit(List<Unit>, int)`: проверяет, является ли юнит самым левым в ряду.

---

### **4. `UnitTargetPathFinderImpl`**
Вычисляет кратчайший путь между атакующим юнитом и целью с использованием обхода графа.

#### **Процесс:**
- Используется подход на основе сетки с приоритетной очередью (алгоритм Дейкстры).
- Занятые клетки считаются препятствиями.
- Путь восстанавливается на основе данных о предшествующих точках.

#### **Основные методы:**
- `initializeDistanceArray()`: инициализирует матрицу расстояний значениями бесконечности.
- `exploreNeighbors(EdgeDistance, Set<String>, int[][], Edge[][], PriorityQueue<EdgeDistance>)`: обновляет расстояния до соседних клеток.
- `constructPath(Edge[][], Unit, Unit)`: восстанавливает путь от атакующего юнита к цели.

---

## **Требования и зависимости**

- **Язык:** Java
- **Библиотека:** `heroes_task_lib`

Убедитесь, что библиотека корректно подключена к проекту.

---

## **Использование**

1. **Интеграция:**
    - Включите проект `heroes_task` в исходный код вашей игры.
    - Убедитесь, что реализации интерфейсов `GeneratePreset`, `SimulateBattle`, `SuitableForAttackUnitsFinder` и `UnitTargetPathFinder` зарегистрированы корректно.

2. **Запуск:**
    - Используйте реализацию `GeneratePreset` для создания армии компьютера.
    - Симулируйте сражения с помощью реализации `SimulateBattle`.
    - Определите атакуемые цели через `SuitableForAttackUnitsFinder`.
    - Вычислите пути перемещения юнитов с помощью `UnitTargetPathFinder`.

3. **Тестирование:**
    - Запустите модульные тесты для проверки работоспособности каждого метода.

---

## **Эффективность алгоритмов**

- **`GeneratePreset`:** O(n log n) (сортировка) + O(n) (выбор).
- **`SimulateBattle`:** O(n² log n), где `n` — количество юнитов.
- **`SuitableForAttackUnitsFinder`:** O(n * m), где `n` — ряды, `m` — юниты в ряду.
- **`UnitTargetPathFinder`:** O((WIDTH × HEIGHT) log(WIDTH × HEIGHT)).

---

## **Дальнейшие улучшения**

- Оптимизация поиска пути с использованием алгоритма A* для эвристического расчёта кратчайших путей.
- Улучшение сортировки и выбора юнитов в `GeneratePreset`, чтобы учитывать динамические атрибуты в бою.
- Повышение масштабируемости для больших армий и полей сражений.

---

## **Автор**
Эта реализация является частью проекта **Heroes Task**, разработанного для реализации ключевых игровых механик в пошаговой стратегии.